1. 

MS = MatrixSpace(GF(2),6,21);

A = MS([[1, 0, 1, 0, 1, 0, 1, 0, 0, 1, 0, 1, 0, 1, 1, 0, 1, 1, 0, 0, 0],
[0, 1, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 1, 0, 1, 0, 1, 1, 1, 1, 0],
[0, 0, 0, 1, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0],
[0, 0, 0, 0, 0, 1, 0, 1, 0, 1, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1],
[0, 0, 0, 0, 0, 0, 1, 0, 1, 1, 1, 0, 1, 1, 0, 1, 1, 1, 1, 0, 1],
[0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 1, 1, 1, 0, 0, 0, 1]])

G = A.echelon_form()

G

[1 0 1 0 1 0 0 0 1 0 1 1 1 0 1 1 0 0 1 0 1]
[0 1 0 0 0 0 0 0 1 0 0 1 0 1 0 0 1 0 0 1 0]
[0 0 0 1 0 0 0 0 0 1 0 0 1 1 0 0 0 1 0 0 1]
[0 0 0 0 0 1 0 0 1 0 1 0 0 0 0 1 1 1 0 0 0]
[0 0 0 0 0 0 1 0 1 1 1 0 1 1 0 1 1 1 1 0 1]
[0 0 0 0 0 0 0 1 1 1 1 1 0 0 1 1 1 0 0 0 1]

1 part 2:

v = matrix(GF(2), [0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 1, 0, 1, 0, 1, 1, 1, 1])

H = G.right_kernel_matrix()

check = H * transpose(v) // Ask do we do mod 2.

check

[0]
[0]
[0]
[0]
[0]
[0]
[1]
[0]
[1]
[1]
[1]
[0]
[1]
[1]
[0] 

It is not a codeword as not the zero vector.

2.

G=Matrix(GF(5), 9, 
[0, 0, 0, 0, 0, 0, 0, 0, 1, 1,
2, 4, 0, 4, 1, 3, 3, 1, 0, 0, 0, 0, 0, 0, 0, 0, 4,
2, 4, 0, 3, 3, 4, 4, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1,
1, 1, 0, 3, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 4,
3, 0, 2, 4, 0, 2, 4, 0, 0, 1, 0, 0, 0, 0, 0, 0, 2,
3, 1, 4, 1, 4, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 2,
3, 0, 2, 3, 3, 4, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
3, 4, 1, 3, 2, 0, 2, 0, 0, 0, 1, 0, 0, 0, 0, 0, 2,
2, 4, 3, 2, 0, 3, 2, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0,
1, 0, 0, 4, 3, 0, 1])

H = G.right_kernel_matrix()

c = matrix(GF(5), [0, 1, 0, 1, 0, 3, 0, 1, 1, 4, 4, 0, 0, 4, 4, 1, 4])

H*transpose(c)

[0]
[0]
[0]
[0]
[0]
[0]
[0]
[0]

Yes it is a generator matrix for the [17,9] code containing c as it is the zero vector. Any message multipled by the parity check matrix gives 0 if and only if the message is generated by the generator matrix.

part 2:

5^9 = 1953125

part 3:

Given a parity check matrix H - we find the smallest number of linearly dependent columns which represents the weight of a codeword which when multiplied with the parity matrix H gives zero and represents the minimum distance.

For our parity check matrix H the distance is: 4

3.

H=Matrix(GF(2),5,
[1,0,0,0,0,1,1,0,0,0,1,
0,1,0,0,0,1,0,1,1,0,0,
0,0,1,0,0,1,1,1,0,0,0,
0,0,0,1,0,1,1,1,0,0,1,
0,0,0,0,1,0,1,1,0,0,1])

G = Matrix(GF(2),6,
[1, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0,
0, 1, 0, 0, 0, 0, 1, 0, 1, 1, 1,
0, 0, 1, 0, 0, 0, 0, 1, 1, 1, 1,
0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0,
0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0,
0, 0, 0, 0, 0, 1, 1, 0, 0, 1, 1])

G is derived from [I|P^t] notation.

G0 = 
[1 0 0 0 0 0 1 1 1 1 0]
[0 1 0 0 0 0 1 0 1 1 1]
[0 0 1 0 0 0 0 1 1 1 1]
[0 0 0 1 0 0 0 1 0 0 0]
[0 0 0 0 1 0 0 0 0 0 0]
[0 0 0 0 0 1 1 0 0 1 1]

G1 = 
[1 0 0 0 0 0 1 1 1 1 0]
[0 1 0 0 0 0 1 0 1 1 1]
[0 0 1 0 0 0 0 1 1 1 1]
[0 0 0 0 1 0 0 1 0 0 0]
[0 0 0 1 0 0 0 0 0 0 0]
[0 0 0 0 0 1 1 0 0 1 1]

G2 = 
[1 0 0 0 0 0 1 1 1 1 0]
[0 0 1 0 0 0 1 0 1 1 1]
[0 0 0 1 0 0 0 1 1 1 1]
[0 0 0 0 0 1 0 1 0 0 0]
[0 0 0 0 1 0 0 0 0 0 0]
[0 1 0 0 0 0 1 0 0 1 1]

part 2:

Number of codes with hamming weight 0: 1
Number of codes with hamming weight 1: 1
Number of codes with hamming weight 2: 1
Number of codes with hamming weight 3: 2
Number of codes with hamming weight 4: 8
Number of codes with hamming weight 5: 18
Number of codes with hamming weight 6: 18
Number of codes with hamming weight 7: 10
Number of codes with hamming weight 8: 3
Number of codes with hamming weight 9: 1
Number of codes with hamming weight 10: 1
Number of codes with hamming weight 11: 0

The distance of C is = 1

part 3:

def SystematicEncoding(G, m):
    GeneratorMatrix = G
    G = copy(GeneratorMatrix.rref())
    pivotPoints = G.pivots()

    loopCounter = 0

    while 1:
        G.swap_columns(loopCounter,pivotPoints[loopCounter])
        pivotPoints = G.pivots()
        loopCounter += 1
        if loopCounter == len(pivotPoints):
            break
    return m*G

part 4:

G = Matrix(GF(2),6,
[1, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0,
0, 1, 0, 0, 0, 0, 1, 0, 1, 1, 1,
0, 0, 1, 0, 0, 0, 0, 1, 1, 1, 1,
0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0,
0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0,
0, 0, 0, 0, 0, 1, 1, 0, 0, 1, 1])

L = matrix(GF(2), [1,0,1,0,0,1])
H = matrix(GF(2), [0,1,1,1,0,0])
E = matrix(GF(2), [1,1,0,1,0,0])
O = matrix(GF(2), [0,0,1,0,1,1])

SystematicEncoding(G, H)
SystematicEncoding(G, E)
SystematicEncoding(G, L)
SystematicEncoding(G, L)
SystematicEncoding(G, O)

H = [0 1 1 1 0 0 1 0 0 0 0]

E = [1 1 0 1 0 0 0 0 0 0 1]

L = [1 0 1 0 0 1 0 0 0 1 0]

L = [1 0 1 0 0 1 0 0 0 1 0]

O = [0 0 1 0 1 1 1 1 1 0 0]

4.

def DecodeLinear(C, r):
    cosets = []
    for coset in (C.list()):
        cosets.append(r+coset)
    
    index = 0
    lowestIndex = -1
    lowestWeight = sys.maxint

    for coset in cosets:
        hammingWeight = coset.hamming_weight()
        if (hammingWeight > 0 and hammingWeight < lowestWeight):
            lowestWeight = hammingWeight
            lowestIndex = index
        index+=1

    return (r - cosets[lowestIndex])


part 2:

r = vector(GF(2), [0, 0, 1, 1, 0, 1, 1, 1, 0, 0, 0]) = (0, 0, 1, 1, 0, 1, 1, 0, 1, 0, 0)
r1 = vector(GF(2), [1, 1, 0, 0, 1, 0, 0, 1, 1, 0, 0]) = (1, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1)
r2 = vector(GF(2), [0, 0, 1, 1, 1, 0, 1, 0, 0, 0, 0]) = (0, 1, 1, 1, 1, 0, 1, 0, 0, 0, 0)


5.

def parityMatrix(BHC):
    base = 2
    weightDist = [base^power for power in range(0,BHC)]
    hammingSet = [np for np in range(1,base^BHC) if np not in weightDist]
    return matrix(GF(2), [[((div // (base ^ exp)) % base) for div in weightDist[::-1] + hammingSet] for exp in range(BHC)[::-1]])

part 2:

def DecHamming(H, v):
    He = H*transpose(v)
    if(He == transpose(matrix(zero_vector(He.nrows())))):
        return v
    else:
        index = 0
        for i in range(0, len(H.columns())):
            if(He == H.column(i)):
                index = i
                break
        errorVector = matrix(GF(2), [1 if x == i else 0 for x in range(v.ncols())])
        return v - errorVector

part 3:

v = matrix(GF(2), [1, 1, 1, 0, 0, 0, 1, 0, 0, 1, 0, 0, 1, 1, 1])
H = parityMatrix(4)
DecHamming(H,v) gives the following:

[1 1 1 0 0 0 1 0 0 1 0 0 1 1 0]

    

6.

H = 
[1 0 0 0 0 0 0 0 1 1 1 1 1 1 1]
[0 1 0 0 0 1 1 1 0 0 0 1 1 1 1]
[0 0 1 0 1 0 1 1 0 1 1 0 0 1 1]
[0 0 0 1 1 1 0 1 1 0 1 0 1 0 1]

The following is an unrolled table where an element of the ith column of the 15 by 1 identity matrix maps to the ith column of H.


error = 

[1]
[0]
[0]
[0]
[0]
[0]
[0]
[0]
[0]
[0]
[0]
[0]
[0]
[0]
[0]

and corresponding syndrome = 

[1]
[0]
[0]
[0]

error = 

[0]
[1]
[0]
[0]
[0]
[0]
[0]
[0]
[0]
[0]
[0]
[0]
[0]
[0]
[0]

and corresponding syndrome = 

[0]
[1]
[0]
[0]

error = 

[0]
[0]
[1]
[0]
[0]
[0]
[0]
[0]
[0]
[0]
[0]
[0]
[0]
[0]
[0]

and corresponding syndrome = 

[0]
[0]
[1]
[0]

error = 

[0]
[0]
[0]
[1]
[0]
[0]
[0]
[0]
[0]
[0]
[0]
[0]
[0]
[0]
[0]

and corresponding syndrome = 

[0]
[0]
[0]
[1]

error = 

[0]
[0]
[0]
[0]
[1]
[0]
[0]
[0]
[0]
[0]
[0]
[0]
[0]
[0]
[0]

and corresponding syndrome = 

[0]
[0]
[1]
[1]

error = 

[0]
[0]
[0]
[0]
[0]
[1]
[0]
[0]
[0]
[0]
[0]
[0]
[0]
[0]
[0]

and corresponding syndrome = 

[0]
[1]
[0]
[1]

error = 

[0]
[0]
[0]
[0]
[0]
[0]
[1]
[0]
[0]
[0]
[0]
[0]
[0]
[0]
[0]

and corresponding syndrome = 

[0]
[1]
[1]
[0]

error = 

[0]
[0]
[0]
[0]
[0]
[0]
[0]
[1]
[0]
[0]
[0]
[0]
[0]
[0]
[0]

and corresponding syndrome = 

[0]
[1]
[1]
[1]

error = 

[0]
[0]
[0]
[0]
[0]
[0]
[0]
[0]
[1]
[0]
[0]
[0]
[0]
[0]
[0]

and corresponding syndrome = 

[1]
[0]
[0]
[1]

error = 

[0]
[0]
[0]
[0]
[0]
[0]
[0]
[0]
[0]
[1]
[0]
[0]
[0]
[0]
[0]

and corresponding syndrome = 

[1]
[0]
[1]
[0]

error = 

[0]
[0]
[0]
[0]
[0]
[0]
[0]
[0]
[0]
[0]
[1]
[0]
[0]
[0]
[0]

and corresponding syndrome = 

[1]
[0]
[1]
[1]

error = 

[0]
[0]
[0]
[0]
[0]
[0]
[0]
[0]
[0]
[0]
[0]
[1]
[0]
[0]
[0]

and corresponding syndrome = 

[1]
[1]
[0]
[0]

error = 

[0]
[0]
[0]
[0]
[0]
[0]
[0]
[0]
[0]
[0]
[0]
[0]
[1]
[0]
[0]

and corresponding syndrome = 

[1]
[1]
[0]
[1]

error = 

[0]
[0]
[0]
[0]
[0]
[0]
[0]
[0]
[0]
[0]
[0]
[0]
[0]
[0]
[1]

and corresponding syndrome = 

[1]
[1]
[1]
[1]





7.

F.<a> = GF(3^3, "a")
p = vector(0, a, a^2, a+2, (a^2)+2*a, 2*(a^2)+a+2, a^2+a+1, a^2+2*a+2, 2*(a^2)+2, a+1, a^2+a)
h = codes.ReedSolomonCode(11,4,F,p)
h.check_mat()

[              1               0               0               0               0               0               0         a^2 + 1     a^2 + a + 2         2*a + 2             a^2]
[              0               1               0               0               0               0               0           2*a^2 2*a^2 + 2*a + 1           a + 2       2*a^2 + 2]
[              0               0               1               0               0               0               0               a             a^2     a^2 + a + 1     a^2 + a + 1]
[              0               0               0               1               0               0               0       2*a^2 + 1           a + 2       2*a^2 + 1 2*a^2 + 2*a + 1]
[              0               0               0               0               1               0               0       2*a^2 + a         a^2 + a           a + 1               1]
[              0               0               0               0               0               1               0 2*a^2 + 2*a + 2               2               a         a^2 + 1]
[              0               0               0               0               0               0               1             2*a         2*a + 2     a^2 + a + 2   2*a^2 + a + 1]

part 2:

8

part 3:

The coset is leader is the following:
(0, 0, 0, 0, a, 0, 0, a^2 + 2, 0, 0, 0)
As there are two non zero elements there were two errors in the received message.



